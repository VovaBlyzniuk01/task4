import React from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper,
  Breadcrumbs,
  Link,
  Chip,
  Avatar,
  Grid
} from '@mui/material';
import { useParams, Link as RouterLink } from 'react-router-dom';

const BlogDetail = () => {
  const { id } = useParams();

  // Імітуємо отримання даних про пост
  const getBlogPost = (id) => {
    const posts = {
      1: {
        title: 'Огляд UX презентацій',
        category: 'design',
        date: '24 січня 2024',
        image: '/images/ux-presentation.jpg',
        author: 'Олена Петренко',
        content: `
          <h2>Як створити ефективну UX презентацію</h2>
          <p>Створення переконливої UX презентації - це мистецтво, яке вимагає розуміння як принципів дизайну, так і потреб аудиторії. У цій статті ми розглянемо основні етапи створення презентації, яка не тільки інформативна, але й візуально приваблива.</p>
          
          <h3>1. Підготовка структури</h3>
          <p>Перш ніж почати роботу над дизайном, важливо створити чітку структуру презентації:</p>
          <ul>
            <li>Визначте головну мету презентації</li>
            <li>Складіть план основних пунктів</li>
            <li>Підготуйте необхідні матеріали та дані</li>
          </ul>

          <h3>2. Візуальне оформлення</h3>
          <p>Дизайн презентації повинен відповідати корпоративному стилю та бути зручним для сприйняття:</p>
          <ul>
            <li>Використовуйте контрастні кольори</li>
            <li>Додайте відповідні зображення та діаграми</li>
            <li>Зберігайте консистентність у оформленні</li>
          </ul>

          <h3>3. Представлення даних</h3>
          <p>Важливо правильно подати інформацію, щоб вона була зрозумілою та переконливою:</p>
          <ul>
            <li>Використовуйте реальні приклади</li>
            <li>Додайте статистику та метрики</li>
            <li>Покажіть результати досліджень</li>
          </ul>
        `
      },
      2: {
        title: 'Що таке wireframing?',
        category: 'design',
        date: '15 січня 2024',
        image: '/images/wireframing.jpg',
        author: 'Світлана Вовк',
        content: `
          <h2>Основи wireframing у веб-дизайні</h2>
          <p>Wireframing є фундаментальним етапом у процесі веб-дизайну. Це допомагає визначити структуру сторінки та розташування елементів перед початком детального дизайну.</p>
          
          <h3>Що таке wireframe?</h3>
          <p>Wireframe - це схематичне представлення веб-сторінки або додатку, яке показує:</p>
          <ul>
            <li>Розташування елементів</li>
            <li>Структуру навігації</li>
            <li>Організацію контенту</li>
          </ul>

          <h3>Інструменти для створення wireframes</h3>
          <p>Існує багато інструментів для створення wireframes:</p>
          <ul>
            <li>Figma</li>
            <li>Adobe XD</li>
            <li>Sketch</li>
            <li>Balsamiq</li>
          </ul>
        `
      },
      3: {
        title: 'Основи UI дизайну',
        category: 'ui',
        date: '22 січня 2024',
        image: '/images/ui.jpg',
        author: 'Максим Ковальчук',
        content: `
          <h2>Основи UI дизайну</h2>
          <p>UI дизайн є важливою складовою сучасних цифрових продуктів. Головне завдання UI – забезпечити користувачу інтуїтивно зрозумілий інтерфейс, який спрощує взаємодію з продуктом.</p>
          
          <h3>1. Принципи UI дизайну</h3>
          <p>До основних принципів належать:</p>
          <ul>
            <li><strong>Простота:</strong> Чіткі лінії, мінімалізм в оформленні та зручна навігація.</li>
            <li><strong>Консистентність:</strong> Узгодженість елементів інтерфейсу по всьому продукту.</li>
            <li><strong>Візуальна ієрархія:</strong> Виділення найважливіших елементів за допомогою різних стилів, кольорів та розмірів.</li>
          </ul>
          
          <h3>2. Інструменти для UI дизайну</h3>
          <p>Сучасні дизайнери використовують такі інструменти:</p>
          <ul>
            <li>Figma</li>
            <li>Adobe XD</li>
            <li>Sketch</li>
            <li>InVision</li>
          </ul>
          
          <h3>3. Кращі практики</h3>
          <p>Дотримання кращих практик дозволяє створювати ефективні інтерфейси:</p>
          <ul>
            <li>Проводьте регулярні тестування з користувачами для вдосконалення UI.</li>
            <li>Створюйте адаптивний дизайн, який добре виглядає на будь-яких пристроях.</li>
            <li>Враховуйте принципи доступності (accessibility) для використання усіма категоріями користувачів.</li>
          </ul>
          
          <p>Досліджуючи основи UI дизайну, ви зможете створювати зручні та привабливі інтерфейси, що підвищують задоволеність користувачів та ефективність роботи продукту.</p>
        `
      },
      4: {
        title: 'Створення API Stack',
        category: 'development',
        date: '19 січня 2024',
        image: '/images/apistack.jpg',
        author: 'Марія Шевченко',
        content: `
          <h2>Створення API Stack: Від концепції до реалізації</h2>
          <p>Сучасні додатки значною мірою залежать від ефективної взаємодії між клієнтом та сервером. API Stack є набором технологій, інструментів та архітектурних рішень, які дозволяють створити стабільний, масштабований і безпечний API для вашого продукту.</p>
          
          <h3>1. Основи та компоненти API Stack</h3>
          <p>API Stack включає в себе декілька ключових компонентів:</p>
          <ul>
            <li><strong>Серверна частина:</strong> Вибір середовища та мови програмування (наприклад, Node.js, Python, Java).</li>
            <li><strong>Протоколи та стандарти:</strong> REST, GraphQL, SOAP або gRPC, що визначають спосіб взаємодії між клієнтом і сервером.</li>
            <li><strong>База даних:</strong> Реляційні (PostgreSQL, MySQL) або нереляційні (MongoDB, Cassandra) системи зберігання даних.</li>
            <li><strong>Безпека:</strong> Аутентифікація, авторизація, використання JWT, OAuth2, SSL/TLS для захисту даних.</li>
          </ul>
          
          <h3>2. Технології та інструменти</h3>
          <p>Для створення API Stack часто використовують:</p>
          <ul>
            <li><strong>Express.js:</strong> Фреймворк для Node.js, що спрощує розробку RESTful API.</li>
            <li><strong>GraphQL:</strong> Мова запитів для ефективної взаємодії між клієнтом та сервером.</li>
            <li><strong>Docker:</strong> Контейнеризація додатків для ізоляції середовища розробки та розгортання.</li>
            <li><strong>Kubernetes:</strong> Оркестрація контейнерів для масштабування продукту.</li>
          </ul>
          
          <h3>3. Кращі практики</h3>
          <p>Дотримання кращих практик допомагає створити надійний API:</p>
          <ul>
            <li>Ретельно плануйте архітектуру ще на початкових етапах розробки.</li>
            <li>Використовуйте стандарти документування, такі як OpenAPI.</li>
            <li>Реалізуйте механізми кешування для підвищення продуктивності.</li>
            <li>Регулярно проводьте тестування та моніторинг роботи API.</li>
          </ul>
          
          <p>Створення якісного API Stack є ключовим аспектом сучасної розробки. Використовуючи сучасні технології та дотримуючись кращих практик, ви зможете забезпечити ефективну взаємодію між компонентами вашого продукту.</p>
        `
      },
      5: {
        title: 'Топ 10 JS фреймворків',
        category: 'development',
        date: '13 січня 2024',
        image: '/images/10frameworkjs.jpg',
        author: 'Денис Чен',
        content: `
          <h2>Топ 10 JavaScript фреймворків</h2>
          <p>У сучасній розробці JavaScript фреймворки відіграють ключову роль, пропонуючи готові рішення для створення інтерфейсів, управління станом додатку та реалізації архітектурних рішень.</p>
          
          <h3>1. React</h3>
          <p>React – бібліотека для побудови користувацьких інтерфейсів, яка використовує компонентний підхід та virtual DOM для підвищення продуктивності.</p>
          
          <h3>2. Angular</h3>
          <p>Angular – комплексний фреймворк від Google, що використовує TypeScript, має вбудоване DI та підтримує MVVM архітектуру.</p>
          
          <h3>3. Vue.js</h3>
          <p>Vue.js – легкий і гнучкий фреймворк з простим API, який забезпечує високу продуктивність і легкість інтеграції.</p>
          
          <h3>4. Svelte</h3>
          <p>Svelte – новітній фреймворк, який видаляє надлишковий код під час компіляції, що дозволяє отримати швидкий і легкий у використанні застосунок.</p>
          
          <h3>5. Ember.js</h3>
          <p>Ember.js – фреймворк з акцентом на масштабованість, орієнтований на створення багатофункціональних SPA з вбудованою підтримкою шаблонів і маршрутизації.</p>
          
          <h3>6. Backbone.js</h3>
          <p>Backbone.js – простий фреймворк для організації коду за принципами MVC, що забезпечує базову структуру для веб-додатків.</p>
          
          <h3>7. Meteor</h3>
          <p>Meteor – фреймворк для створення веб-додатків у режимі реального часу, який автоматично синхронізує дані між клієнтом і сервером.</p>
          
          <h3>8. Next.js</h3>
          <p>Next.js – серверний фреймворк на базі React для створення SEO-дружніх застосунків з підтримкою SSR та статичної генерації сторінок.</p>
          
          <h3>9. Nuxt.js</h3>
          <p>Nuxt.js – фреймворк для Vue.js, який спрощує розробку універсальних застосунків з підтримкою серверного рендерингу.</p>
          
          <h3>10. Gatsby</h3>
          <p>Gatsby – генератор статичних сайтів на базі React, орієнтований на високу продуктивність, швидкість завантаження та оптимізацію SEO.</p>
          
          <h3>Висновок</h3>
          <p>Вибір фреймворку залежить від специфіки проекту, вимог до продуктивності та досвіду команди. Кожен з цих фреймворків має свої сильні та слабкі сторони, що дозволяє знайти оптимальне рішення для конкретного завдання.</p>
        `
      },
      6: {
        title: 'Мікросервісна архітектура',
        category: 'engineering',
        date: '18 січня 2024',
        image: '/images/microarxitec.jpg',
        author: 'Ігор Сидоренко',
        content: `
          <h2>Мікросервісна архітектура: Розбиття моноліту на частини</h2>
          <p>Мікросервісна архітектура – це підхід до розробки програмного забезпечення, який розбиває великий монолітний додаток на набір невеликих, автономних сервісів. Кожен сервіс виконує певну бізнес-функцію та може розгортатися, масштабуватися та оновлюватися окремо від інших.</p>
          
          <h3>1. Основні принципи</h3>
          <ul>
            <li><strong>Декомпозиція:</strong> Розбиття системи на незалежні компоненти з чітко визначеними інтерфейсами.</li>
            <li><strong>Незалежність розгортання:</strong> Кожен сервіс може оновлюватися без порушення роботи інших частин додатку.</li>
            <li><strong>Масштабованість:</strong> Окреме масштабування кожного сервісу залежно від навантаження.</li>
            <li><strong>Відмовостійкість:</strong> Помилка одного сервісу не повинна негативно впливати на всю систему.</li>
          </ul>
          
          <h3>2. Переваги та виклики</h3>
          <p>Серед основних переваг:</p>
          <ul>
            <li>Гнучкість оновлень і розгортання.</li>
            <li>Легкість масштабування окремих компонентів.</li>
            <li>Полегшення обслуговування різних частин системи.</li>
          </ul>
          <p>Серед викликів:</p>
          <ul>
            <li>Складність взаємодії між сервісами.</li>
            <li>Необхідність налаштування централізованого моніторингу та журналювання.</li>
            <li>Проблеми з мережею, що можуть впливати на продуктивність.</li>
          </ul>
          
          <h3>3. Технології та інструменти</h3>
          <p>Для реалізації мікросервісної архітектури використовують:</p>
          <ul>
            <li><strong>Docker та Kubernetes:</strong> Контейнеризація та оркестрація для ізоляції та управління сервісами.</li>
            <li><strong>REST API та gRPC:</strong> Протоколи для комунікації між сервісами.</li>
            <li><strong>Моніторинг:</strong> Використання Prometheus, Grafana для відстеження продуктивності.</li>
          </ul>
          
          <h3>4. Висновок</h3>
          <p>Використання мікросервісної архітектури дозволяє створювати гнучкі, масштабовані та легко обслуговувані додатки. Незважаючи на певні виклики інтеграції, переваги у вигляді незалежного розгортання та масштабування сприяють високій продуктивності системи.</p>
        `
      },
      7: {
        title: 'DevOps практики',
        category: 'engineering',
        date: '11 січня 2024',
        image: '/images/devops.jpg',
        author: 'Василь Мороз',
        content: `
          <h2>DevOps практики</h2>
          <p>Найкращі практики DevOps для оптимізації процесу розробки та розгортання. У цьому дописі ми розглянемо основні принципи впровадження DevOps, зосереджуючись на автоматизації, моніторингу та спрощенні процесів.</p>
          <h3>Основні принципи</h3>
          <ul>
            <li>Контроль версій</li>
            <li>Автоматизація тестування та розгортання</li>
            <li>Безперервна інтеграція та доставлення</li>
          </ul>
        `
      },
      // ... додайте описи для інших постів
    };
    return posts[id];
  };

  const post = getBlogPost(Number(id));

  const galleryImages = [
    '/images/ux.jpg',
    '/images/wireframing.jpg',
    '/images/ui.jpg',
    '/images/apistack.jpg',
    '/images/10frameworkjs.jpg',
    '/images/microarxitec.jpg',
    '/images/devops.jpg'
  ];

  // Функция для сопоставления имени автора и пути к аватарке
  const getAuthorAvatar = (authorName) => {
    const map = {
      "Олена Петренко": "/avatar/olena-petrenko.jpg",
      "Світлана Вовк": "/avatar/svitlana-vovk.jpg",
      "Максим Ковальчук": "/avatar/maksym-kovalchuk.jpg",
      "Марія Шевченко": "/avatar/maria-shevchenko.jpg",
      "Денис Чен": "/avatar/denis-chen.jpg",
      "Ігор Сидоренко": "/avatar/ihor-sydorenko.jpg",
      "Василь Мороз": "/avatar/vasyl-moroz.jpg"
    };
    return map[authorName] || '/avatar/default.jpg';
  };

  if (!post) {
    return (
      <Container maxWidth="lg" sx={{ py: 4 }}>
        <Typography variant="h4">Пост не знайдено</Typography>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      {/* Хлібні крихти */}
      <Breadcrumbs sx={{ mb: 3 }}>
        <Link component={RouterLink} to="/" color="inherit">
          Блог
        </Link>
        <Typography color="text.primary">{post.title}</Typography>
      </Breadcrumbs>

      {/* Заголовок */}
      <Typography variant="h3" component="h1" sx={{ mb: 3, fontWeight: 600 }}>
        {post.title}
      </Typography>

      {/* Мета-інформація */}
      <Box sx={{ mb: 4, display: 'flex', alignItems: 'center', gap: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar 
            src={getAuthorAvatar(post.author)}
            alt={post.author}
          />
          <Typography variant="body2">{post.author}</Typography>
        </Box>
        <Typography variant="body2" color="text.secondary">
          {post.date}
        </Typography>
        <Chip 
          label={post.category} 
          size="small"
          color="primary"
          sx={{ textTransform: 'capitalize' }}
        />
      </Box>

      {/* Головне зображення */}
      <Box 
        component="img"
        src={post.image}
        alt={post.title}
        sx={{
          width: '100%',
          height: 'auto',
          borderRadius: 2,
          mb: 4
        }}
      />

      {/* Контент */}
      <Paper 
        sx={{ 
          p: 4,
          '& h2': {
            fontSize: '1.5rem',
            fontWeight: 600,
            mb: 2
          },
          '& h3': {
            fontSize: '1.25rem',
            fontWeight: 600,
            mb: 2,
            mt: 4
          },
          '& p': {
            mb: 2,
            lineHeight: 1.7
          },
          '& ul': {
            mb: 2,
            pl: 2
          },
          '& li': {
            mb: 1
          }
        }}
      >
        <div dangerouslySetInnerHTML={{ __html: post.content }} />
      </Paper>

      {/* Галерея изображений */}
      <Typography variant="h5" sx={{ mt: 4, mb: 2, fontWeight: 600 }}>
        Галерея
      </Typography>
      <Grid container spacing={2}>
        {galleryImages.map((imgSrc, index) => (
          <Grid item xs={12} sm={6} md={4} key={index}>
            <Box
              component="img"
              src={imgSrc}
              alt={`Галерея ${index + 1}`}
              sx={{ width: '100%', borderRadius: 1 }}
            />
          </Grid>
        ))}
      </Grid>
    </Container>
  );
};

export default BlogDetail; 